\chapter{Ejercicio 2}

Para demostrar que las desigualdades son válidas, se utilizará el método del absurdo y demostración por inducción. La desigualdad es válida para el $CP$ original (sin relajación) si la desigualdad se cumple para todos los puntos dentro de la cápsula convexa de soluciones factibles enteras. Por lo tanto el planteo inicial será suponer que el punto no cumple con la nueva restricción pero sí con las condiciones originales.

Supongamos que existe un coloreo válido para el $CP$ original. Por lo tanto existe $W$ = $(w_0, w_1, ... , w_n)$ y $X = \{x_{vj} | v = 0, ..., n \wedge j = 0, ..., n\}$, donde $v$ son los nodos y $j$ son los colores con los que se pintaron los mismos. Entonces para $X$ vale:

\begin{enumerate}
\item $\displaystyle\sum_{j = 1}^{n} x_{pj} = 1$, $\forall$ $p \in V$

\item $x_{pj} + x_{qj} \le w_j$, $\forall$ $(p,q) \in E$, $j = 1,...,n$

\item $x_{pj} \in \{0,1\}$, $\forall$ $p \in V$, $j = 1,...,n$

\item $w_j \in \{0,1\}$, $\forall$ $j = 1,...,n$

\end{enumerate}

\section{Demostración Desigualdad 1: Clique}

Sea K una Clique del grafo y sea $j_0$ cualquier color tal que $1 \le j_0 \le n$. Supongamos que la solución no cumple con la desigualdad clique, entonces sabemos que vale lo siguiente:

$$\displaystyle\sum_{p \in K} x_{pj_0} > w_{j_0}$$

\begin{itemize}

\item Supongamos que $|K| = 2$. Sean dos nodos cualesquiera $p_1$ y $p_2$ de la Clique, entonces vale que:

$$x_{{p_1}{j_0}} + x_{{p_2}{j_0}} > w_{j_0}$$

Pero por otro lado, como K es una clique, sabemos que existe un eje $({p_1},{p_2})$ de modo que se cumple la condición (2) del $CP$ original:

$$x_{{p_1}{j_0}} + x_{{p_2}{j_0}} \le w_{j_0}$$

Pero esto resulta ser absurdo ya que no puede pasar que $A > w_{j_0}$ y que $A \le w_{j_0}$ siendo $A = x_{{p_1}{j_0}} + x_{{p_2}{j_0}}$.$\qed$


\item Supongamos ahora que $|K| > 2$. Sean tres nodos cualesquiera $p_1$, $p_2$ y $p_3$ de la Clique, entonces vale que:

$$x_{{p_1}{j_0}} + x_{{p_2}{j_0}} + x_{{p_3}{j_0}} + ... + x_{{p_n}{j_0}} > w_{j_0}$$

Por otro lado, como K es una clique, sabemos que existen ejes $({p_1},{p_2})$, $({p_2},{p_3})$, $({p_3},{p_1})$ de modo que se cumplen las condiciones (2) del $CP$ original:

$$x_{{p_1}{j_0}} + x_{{p_2}{j_0}} \le w_{j_0}$$

$$x_{{p_2}{j_0}} + x_{{p_3}{j_0}} \le w_{j_0}$$

$$x_{{p_3}{j_0}} + x_{{p_1}{j_0}} \le w_{j_0}$$

\medskip
Entonces vale decir lo siguiente:

$$x_{{p_1}{j_0}} + x_{{p_2}{j_0}} \le w_{j_0} < x_{{p_1}{j_0}} + x_{{p_2}{j_0}} + x_{{p_3}{j_0}} + ... + x_{{p_n}{j_0}}$$

Por lo tanto se deduce lo siguiente:

$$x_{{p_3}{j_0}} + ... + x_{{p_n}{j_0}} > 0$$

Podemos suponer, sin pérdida de generalidad, que $x_{{p_3}{j_0}} = 1$.

\medskip
Por otro lado tenemos que:

$$x_{{p_2}{j_0}} + x_{{p_3}{j_0}} \le w_{j_0}$$

Por condición (2) del $LP$ original. Entonces vale lo siguiente:

$$x_{{p_2}{j_0}} + x_{{p_3}{j_0}} \le w_{j_0} < x_{{p_1}{j_0}} + x_{{p_2}{j_0}} + x_{{p_3}{j_0}} + ... + x_{{p_n}{j_0}}$$

Por lo tanto:

$$x_{{p_1}{j_0}} + x_{{p_4}{j_0}} + ... + x_{{p_n}{j_0}} > 0$$

Nuevamente, sin pérdida de generalidad suponemos que $x_{{p_1}{j_0}} = 1$. Pero se sabía por lo anterior que:

$$x_{{p_3}{j_0}} + x_{{p_1}{j_0}} \le w_{j_0}$$

Por lo tanto, se llega a que:

$$w_{j_0} \geq 2$$

Lo cual resulta absurdo, pues por (4) $w_j \in \{0, 1\} \forall 1 \le j \le n$. $\qed$

\end{itemize}

Dado que no hay más alternativas, la suposición de que la desigualdad no se cumple es falsa. $\qed$

\section{Demostración Desigualdad 2: Agujero de Longitud Impar}

Sea $C_{2k+1}$ el conjunto de vértices dentro de un agujero de longitud $2k+1$, con $k >= 2$. Supongamos que la solución no cumple con la desigualdad agujero impar. Por lo tanto podemos decir que $\exists k >= 2$ tal que:

$$
\sum_{p \in C_{2k+1}} x_{p{j_0}} > kw_{j_0}
$$

Con $j_0$ cualquier color tal que $1 \le j_0 \le n$.

\begin{itemize}
\item Supongamos que $w_{j_0} = 0$. Para este caso la desigualdad quedaría de la siguiente forma:

$$
\sum_{p \in C_{2k+1}} x_{p{j_0}} > 0
$$
      
Como se puede observar, la restricción se cumple si existe algún nodo $p$ del agujero $C_{2k+1}$ tal que $x_{p{j_0}} = 1$. Dado que no hay nodos aislados, podemos tomar un eje $(p,p')$ de modo que se cumple la condición (2) del $CP$ original:

$$x_{{p}{j_0}} + x_{{p'}{j_0}} \le w_{j_0}$$

O sea que

$$x_{{p'}{j_0}} + 1 \le w_{j_0}$$

Pero por (3) $x_{{p'}{j_0}} \in \{0,1\}$, y $w_{j_0} = 0$, o sea que $x_{{p'}{j_0}} + 1 \le 0$ lo cual es absurdo. $\qed$

\item Supongamos ahora que $w_{j_0} = 1$. Para este caso la desigualdad quedaría de la siguiente forma:

$$
\sum_{p \in C_{2k+1}} x_{p{j_0}} > k
$$
      
La restricción entonces se cumple si hay almenos $k+1$ nodos del agujero pintados con el color $j_0$.

Para un circuito de longitud $2k+1$, la máxima cantidad de nodos pintados del mismo color para que su coloreo sea válido es $k$. Como los nodos del agujero conforman un circuito de longitud impar, si pintamos $k+1$ o más nodos del mismo color, este coloreo sería inválido para el mismo circuito, por lo tanto hay almenos dos nodos que son adyacentes entre sí y están pintados del mismo color. Por consiguiente el coloreo es inválido y la suposición de que $w_{j_0} = 1$ es absurda. $\qed$

\end{itemize}

Dado que no hay más alternativas, la suposición de que la desigualdad no se cumple es falsa. $\qed$


\section{Heurística de Separación: Clique}

Se implementó un callback llamado $cortes$ que se lo setea a $CPLEX$ como heurística de separación. Este callback se ejecuta juesto luego de que $CPLEX$ haya encontrado la solución para un nodo del árbol de branching, y llama a nuestra función de separación por cortes clique, llamada $corteClique$.

La idea de este método es bastante simple, y se procede a realizar la descripción de sus pasos a continuación:

\begin{enumerate}
\item Se toma la solución $X$ que encontró $CPLEX$ para el nodo actual del árbol de branching. Este vector tiene una cantidad determinada columnas, las cuales se corresponden con las variables $w_j$ de colores y $x_pj$ de nodos/colores del grafo. De todas estas columnas nos quedamos solamente con aquellas que se correspondan con los $x_pj$ tal que su valor $k$ sea $0 \le k < 1$. Recordar que estos valores son de punto flotante debido a la relajación.

\item Dado que buscamos la clique de mayor valor de sumatoria del valor de sus variables asociadas, recorremos este vector de mayor a menor intentando agregar un nuevo nodo en cada paso. Notar que este es un vector de variables del modelo, por lo tanto para testear si se puede agregar o no un nuevo nodo a la clique en construcción, dada la columna $x_pj$, averiguamos el $p$ y el $j$ confiando fuertemente en el formato del archivo $.lp$ de entrada, ya que estos cálculos dependen del orden de las columnas en la sección $Binary$. Si $j$ es del mismo color que el primer elemento del vector ordenado (que siempre es agregado como primer nodo) y si $p$ es vecino de todos los nodos de la clique actual, se procede a agregar el nodo y se guarda también la columna relacionada.

\item Luego de agregar un nuevo nodo verificamos si la desigualdad

$$\displaystyle\sum_{p \in K} x_{pj_0} > w_{j_0} + \epsilon$$

se cumple. Esto quiere decir que la desigualdad clique es violada y por lo tanto podemos agregar un corte (gracias a lo demostrado anteriormente) y la heurística termina. Utilizamos un margen de error $\epsilon = 0.000001$.
\end{enumerate}

A continuación se agrega el pseudocódigo para mostrar mejor la idea que se explico anteriormente.

\begin{algorithm}[H]
\caption{Corte Clique}
%\label{alg:algoritmo2_1}
\begin{algorithmic}[1]
\PARAMS{Datos de $CPLEX$}
\STATE Ordenar los x\'s de acuerdo a su valor y que estén entre 0 (inclusive) y 1 (exclusive).
\STATE Obtener el nodo asociado a la columna $X_m$ con mayor valor.
\STATE Agregar $X_m$ a la clique $K$
\FOR{Cada columna $X_i$ que siguen en el ordenamiento y que tenga el mismo color que $X_m$}
	\IF{El nodo relacionado con la columna $X_i$ es adyacente a todos los nodos de $K$}
		\STATE agregar el nodo a $K$
		\IF{la sumatoria de valores de $K$ es mayor que el valor de $w_{j0} + \epsilon$, donde j0 es el color de $X_m$}
			\STATE Generar la desigualdad basada en $K$, agregarla al problema y salir del ciclo.
		\ENDIF
	\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

La idea de esta heurística fue extraída del paper ``A branch-and-cut algorithm for graph coloring'' de Isabel Méndez Díaz y Paula Zabala, como se puede ver en las referencias (sección \ref{cliquecutalgorithm}).


\section{Heurística de Separación: Agujero Impar}

El método que realiza los cortes de tipo agujero impar es $corteCicloImpar$, que es llamado por $cortes$, el cual a su vez se llama cada vez que $CPLEX$ intenta hacer un corte. La idea del funcionamiento de este método es simple. Se parte de la misma base que la heurística de clique descripta anteriormente, es decir partiendo de la base de que los valores relacionados a cada nodo se encuentran ordenados de mayor a menor, para maximizar la probabilidad en este caso de encontrar un ciclo que viole la desigualdad agujero impar. A continuación se describen los pasos mas importantes del algoritmo.

\begin{enumerate}
\item Una vez recibidos los datos que son pasados por $CPLEX$ y con los nodos ordenados de mayor a menor, lo que se hace es partir del nodo con mayor valor y realizar un BFS, de manera de construir un árbol en base al grafo relacionado al problema actual. El método hace varias iteraciones partiendo siempre desde distinto nodo, de mayor a menor valor de columna asociada. Tiene un límite dado para la cantidad de iteraciones y para cada iteración, otro límite dado para la cantidad de ciclos verificados.
\item A medida que se hace el BFS y a medida que va creciendo el árbol, se verifica si existen ciclos impares entre cada par de nodos $h_1$ y $h_2$ que sean hojas en ese paso y sean adyacentes entre sí. Esto no se hace para todo par de hojas $h_1$ y $h_2$, sino solamente para aquellas que vengan de diferente hijo de la raíz. Es decir, dos hojas $h_1$ y $h_2$ vienen de diferentes hijos de la raíz $r_1$ y $r_2$ si, al eliminar la raíz del árbol de BFS actual, existe un camino desde $r_1$ a $h_1$ y otro desde $r_2$ a $h_2$, con $r_1 \neq r_2$.
\item Un vez que se sabe que existe un ciclo impar se llama a otro método: $tryToAddOddCycleCut$. Este se encarga de reconstruir el ciclo encontrado y verificar si la desigualdad de agujero impar no se cumple para cada uno de los colores disponibles. Si no se cumple, entonces se agrega una restricción al problema (notar que en una llamada a $tryToAddOddCycleCut$ se puede agregar más de 1 restricción al problema, si es que para 2 o mas colores se encuentra que la desigualdad se viola), sino se continúa repitiendo el proceso de BFS.
Cabe aclarar además, que si bien para cada ciclo encontrado, pueden agregarse 0, 1 o más restricciones nuevas al problema, se pueden agregar más restricciones a medida que se sigue recorriendo el grafo en orden BFS, ya que cuando se encuentra un ciclo y este genera alguna restricción nueva al problema, el proceso no se detiene hasta tanto se haya recorrido toda la componente conexa o se haya llegado al límite de búsqueda de ciclos.
\end{enumerate}

Para explicar mejor el algoritmo, veamos su pseudocódigo:

\begin{algorithm}[H]
\caption{Corte Agujero Impar}
%\label{alg:algoritmo2_1}
\begin{algorithmic}[1]
\PARAMS{Datos de $CPLEX$}
\STATE Ordenar los x\'s de acuerdo a su valor y que estén entre 0 y 1.
\STATE Obtener el nodo asociado $r$ a la columna $X_m$ con mayor valor.
\STATE \COMMENT{Se comienza a realizar el proceso de BFS.}
\STATE Tomar el nodo $r$ como raíz principal para formar el árbol $A_{BFS}$, marcar su nivel en $0$, su raíz $n_m$ y su padre $-1$.
\FOR{Cada nodo $r_{ady}$ adyacente a $r$}
	\STATE $Nivel(r_{ady}) \leftarrow 2$
	\STATE $Raiz(r_{ady}) \leftarrow r_{ady}$
	\STATE $Padre(r_{ady}) \leftarrow r$
\ENDFOR
\FOR{Cada nodo $n_i$ que sigue en el recorrido BFS}
	\IF{Aún no se alcanzó el límite de ciclos verificados}
		\FOR{Cada nodo $n_k$ en $Vecinos(n_i)$}
			\IF{$Nivel(n_k) > -1$}
				\STATE $tamanoCiclo \leftarrow Nivel(n_i) + Nivel(n_k) + 1$
				\IF{$n_k$ no es el padre de $n_i$ y tamanoCiclo es impar, mayor a 4 y $Raiz(n_k) \neq Raiz(n_i)$}
						\STATE $tryToAddOddCycleCut(n_k, n_i, Padre, r)$
				\ENDIF
			\ELSE
				\STATE $Nivel(n_k) \leftarrow Nivel(n_i) + 1$
				\STATE $Raiz(n_k) \leftarrow Raiz(n_i)$
				\STATE $Padre(n_k) \leftarrow n_i$
			\ENDIF
		\ENDFOR
	\ENDIF
\ENDFOR
\end{algorithmic}
\end{algorithm}

La idea del método $tryToAddOddCycleCut$ es simple y no necesita demasiado detalle. En este se aprobecha la información construída de los padres de cada nodo para reconstruir el ciclo. A su vez se va calculando la sumatoria de los valores correspondientes a las columnas $x_{pj_0}$ tal que $p \in OddCycle$ y todas tienen el mismo $j_0$. Luego este valor se lo compara con $w_{j_0}$ de la siguiente manera:

$$\sum_{p \in C_{2k+1}} x_{p{j_0}} > kw_{j_0}$$

siendo k el tamaño del ciclo. Si esto se cumple quiere decir que la desigualdad $Odd-Hole$ es violada, por lo tanto agregamos una restricción al problema. Además, como dijimos, se prueba esta desigualdad para todo color $j_0$.

La idea del algoritmo fue extraída del paper ``Solving Airline Crew Scheduling Problems by Branch-and-Cut'' de Karla L. Hoffman y Manfred Padberg, como se puede ver en las referencias (sección \ref{oddcyclecutalgorithm}).