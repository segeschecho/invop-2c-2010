\section{Ejercicio 1}

El objetivo de este ejercicio consiste en poner a prueba el problema de coloreo, variando algunos de los parámetros que $CPLEX$ utiliza para resolver el problema. Los mismos son parámetros genéricos que forman parte del comportamiento que tiene $CPLEX$ para computar la solución.

En este caso en particular, se tomaron parámetros que se utilizan en el método de Branch and Bound. La prueba entonces, consiste en modificar los valores de dichos parámetros y observar como es el desempeño del proceso, en tiempo requerido y en cantidad de nodos creados por $CPLEX$, hasta obtener la solución del problema.

Los parámetros elegidos son los siguientes:

\begin{enumerate}

\item \textbf{CPX\_PARAM\_BRDIR:} Este parámetro sirve para modificar la dirección en la cual se hará en branching en cada paso. Los posibles valores para el mismo son los siguientes:
   \begin{itemize}
   \item CPX\_BRDIR\_UP, que indica que el branching siempre debe hacerse por la parte superior.
   \item CPX\_BRDIR\_DOWN, que indica que el branching debe hacerse por la parte inferior.
   \item CPX\_BRDIR\_AUTO, que indica que $CPLEX$ decidirá que camino tomar.
   \end{itemize}

\item \textbf{CPX\_PARAM\_LBHEUR:} Indica si las heurísticas locales en cada branching están o no activadas. Los valores para el mismo son: CPX\_ON y CPX\_OFF.

\item \textbf{CPX\_PARAM\_VARSEL:} CPX\_PARAM\_LBHEUR depende de este parámetro, que indica que estrategia usar para seleccionar una variable antes de realizar el branching. Los posibles valores son:
    \begin{itemize}
    \item CPX\_VARSEL\_MININFEAS, que realiza el branch con la variable con inviabilidad mínima (es decir, la variable fraccionaria mas cercana a algún valor entero).
    \item CPX\_VARSEL\_MAXINFEAS, que realiza el braching con la variable mas inviable(es decir la mas lejana a un valor entero)
    \item CPX\_VARSEL\_PSEUDO, la variable es elegida a través de pseudo costos.
    \item CPX\_VARSEL\_STRONG, elije la variable a través de la resolución de diferentes sub problemas que permiten saber cuan prometedora es la elección de dicha variable.
    \item CPX\_VARSEL\_PSEUDOREDUCED, selecciona la variable basado en costos.
    \end{itemize}

\item \textbf{CPX\_PARAM\_NODESEL}, estrategia de selección de cada nodo, para el arbol de backtracking de branch and bound.
  	\begin{itemize}
   	\item CPX\_NODESEL\_DFS: Selecciona el seguiente nodo de acuerdo al recorrido de DFS.
   	\item CPX\_NODESEL\_BESTBOUND: Selecciona el siguiente nodo que tiene mejor función objetivo para el problema actual relajado.
   	\item CPX\_NODESEL\_BESTEST: Selecciona el nodo con la mejor estimación del valor objetivo entero, que puede ser obtenido una vez que todos los valores enteros inviables, hayan sido removidos.
   	\end{itemize}

\item \textbf{CPX\_PARAM\_STRONGITLIM:} Indica el límite de iteraciones a realizar en cada una de las variables candidatas para realizar el branching. Los valores que puede tomar son: 0, automático o un número positivo, que indica las iteraciones fijas a realizar.

\item \textbf{CPX\_PARAM\_ZEROHALFCUTS:} Aquí se indica si se harán o no cortes de tipo parte entera hacia abajo para los valores del lado derecho de las restricciones. Los posibles valores son: -1, desactivado, 0 automático, 1 normal y 2 agresivo.
\end{enumerate}

\subsection{Pruebas realizadas}

En lo que sigue de la sección actual, se mostrarán los resultados de varias rondas de tests,las cuales involucran la combinación de diferentes parámetros de $CPLEX$. Además, se irá contando cuales fueron los problemas encontrados en cada una de las rondas y como se fueron seleccionando los mejores valores de los parámetros, para realizar las pruebas finales.

Además de los parámetros descriptos, se modificó la configuración global de $CPLEX$ para analizar solo el comportamiento del método branch and bound. Para esto, se deshabilitaron algunas características que vienen configuradas por defecto. Las heurísticas de preproceso de la información y de reducción variables fueron deshabilitadas, para esto se setearon los parámetros $CPX\_PARAM\_REDUCE$ y $CPX\_PARAM\_MIPCBREDLP$ en $off$ y el parámetro $CPX\_PARAM\_PRELINEAR$ en cero.

Además de esta configuración, se desactivaron todos los métodos que realizan cortes en el problema. Para esto entonces, se setearon los parámetros $CPX\_PARAM\_CUTPASS$ en -1 y $CPX\_PARAM\_CUTSFACTOR$ en cero.

Es cierto que con lo anteriormente realizado la performace disminuye a la hora de resolver los problemas, pero su fin es evaluar el comportamiento del método branch and bound exclusivamente.

Por último, se deshabilitó la salida por consola de los resultados de las iteraciones para disminuír los tiempos de ejecución.

La pc en la que se realizaron todas las pruebas es un $Athlon$ $64$ $3000+$ con $1.80Ghz$ de velocidad de procesador, un solo núcleo y con $1GB$ de memoria Ram $DDR2$ de $800Mhz$.

\subsubsection{Ronda Número 1}

La primer ronda consistió en realizar tests combinando los parámetros 1, 2, 5 y 6, con lo que se obtuvo $24$ tipos distintos de tests. Los mismos recibían como parámetros grafos de 3 a 13 nodos, con una densidad de $70\%$ de aristas. La relativamente poca cantidad de nodos se debe a que la PC en la que se realizaban todas las pruebas no podía resolver coloreo con grafos de 14 o más nodos, dado que la cantidad de memoria de la que disponía no alcanzaba, y por este motivo $CPLEX$ devolvía un error que informaba dicho problema.

A continuación se hará una descripción de cada uno de los 24 (venticuatro) tipos de tests:

\begin{enumerate}

\item Tipo1:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo2:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo3:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo4:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo5:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo6:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2  *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo7:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo8:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo9:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo10:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo11:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo12:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo13:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo14:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo15:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo16:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo17:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo18:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo19:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MININFEAS *\\

\item Tipo20:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1   *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo21:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo22:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo23:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\item Tipo24:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_MAXINFEAS *\\

\end{enumerate}

A continuación se mostrarán los gráficos de tiempo para cada uno de los tipos de tests, y para cada uno de los grafos de 3 a 13 nodos, con $70\%$ de densidad. El primer gráfico, si bien no deja que se observe la información de cada uno de los tests, nos sirve para ver cómo es que el aumento del tiempo es directamente proporcional a la cantidad de nodos en el grafo. Como se puede observar en cada valor del eje horizontal X, si bien cada uno de los valores de cada grupo de resultados varía entre los demás del mismo grupo, podemos observar que el patrón es similar, el aumento del tiempo de procesamiento se torna exponencial a medida que aumenta la cantidad de nodos del grafo:

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../tests/resultados/resultados1/tiempos.png}
\caption{Vista de la complejidad exponencial}
\end{figure}

Como se puede observar, además de que los tiempos se tornan exponenciales, también resultan ser muy altos para este problema si se tiene en cuenta que los grafos que se usaron en los tests son pequeños. Como se puede observar en la figura anterior, para un grafo de 13 nodos, con 70\% de densidad, los tests estan tardando entre 1200 y 3000 segundos aproximadamente (es decir entre 20 y 50 minutos) en resolver el problema de coloreo para dicho grafo en particular. Por esta razón se llegó a la conclusión de que es necesario realizar algún cambio para disminuír los tiempos de respuesta.

Luego de algunas pruebas aisladas, se pudo observar que uno de los factores que hacían que los tiempos sean tan altos era el método para seleccionar la variable para realizar el branching.

El control de dicha metodología se setea mediante el parámetro de configuración $CPX\_PARAM\_VARSEL$ y las pruebas realizadas tuvieron solo dos posibles valores en todos los test descriptos anteriormente. Uno selecciona la variable con la mínima infactibilidad y realiza el branching con dicha variable, y el otro selecciona la variable con la mayor factibilidad. En las pruebas aisladas se probó que se puede llegar a mejores resultados seteando la selección de las variables para realizar el branching en modo automático, es decir, dejando que $CPLEX$ eligiera que variable convenía de acuerdo a su metodología.

En esto entonces se basan los tests realizados por la ronda número dos, que se explicarán en la siguiente sección.

\subsubsection{Ronda Número 2}

En esta ronda se realizaron tests seteando el parámetro $CPX\_PARAM\_VARSEL$ en automático, de forma que $CPLEX$ seleccionará la variable que mejor le convenga para realizar el branching. De esta forma la cantidad de tipos de tests a realizar disminuyó a 12 (doce).

A continuación se describen cada uno de los tipos tests, como se hizo en la sección anterior, para los valores utilizados en esta ronda:

\begin{enumerate}
\item Tipo1:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo2:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1   *normal\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo3:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo4:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo5:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo6:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_DOWN\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo7:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ -1\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo8:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo9:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 1\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 2 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo10:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo11:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\
CPX\_PARAM\_STRONGITLIM $\to$ 5 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\item Tipo12:

CPX\_PARAM\_BRDIR $\to$ CPX\_BRDIR\_UP *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\
CPX\_PARAM\_STRONGITLIM $\to$ 2 *\\
CPX\_PARAM\_ZEROHALFCUTS $\to$ 1 *\\
CPX\_PARAM\_VARSEL $\to$ CPX\_VARSEL\_DEFAULT\\

\end{enumerate}

El resultado de estos tests los veremos en el siguiente gráfico, donde se puede observar que los tiempos requeridos para resolver los problemas son significativamente menores, aunque siguen siendo relativamente altos. Con la combinación actual de parámetros, para el grafo de mayor cantidad de nodos los tiempos rondan entre los 200 y 750 segundos (osea entre 3 y 13 minutos aproximadamente). En la siguiente imagen, se muestran los tiempos para grafos de hasta 12 nodos.

%\begin{figure}[H]
%\centering
%\includegraphics[scale=0.75]{../tests/resultados/resultados2/tiempos3-12-nodos.png}
%\caption{Vista de la complejidad exponencial hasta gafos de 12 nodos}
%\end{figure}

%Como se puede observar, los tipos 7, 8 y 9 en general son los que menos tiempo requieren para resolver el problema. Con esto se puede pensar que dichas combinaciones son las mejores entre todas las que se testearon, aunque esto no se pude tomar como totalmente cierto, en las rondas de tests se tomará alguno de los tipos que se tienen actualmente para realizar otros tests. Como la idea es que la cantidad de tipos de test no sea muy grande, se tomará la mejor combinación de valores, que se elegirá de acuerdo a los resultados que se obtengan. Por este motivo, al ver los resultados actuales, pareciera ser que los tipos 7, 8 y 9 son los mejores en general. A continuación se muestra el gráfico global de los tests para cada tipo, de grafos de 3 nodos a grafos de 13 nodos:

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{../tests/resultados/resultados2/tiempos3-13-nodos.png}
\caption{Vista de la complejidad exponencial hasta gafos de 13 nodos}
\end{figure}

Para observar más detalladamente qué ocurre cuando se recibe un grafo de 13 nodos, se hará un zoom al gráfico anterior, que mostrará solamente los tiempos de cada uno de los tipos de tests para dicho grafo.

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{../tests/resultados/resultados2/tiempos13-nodos.png}
\caption{Vista de la complejidad exponencial hasta gafos de 12 nodos}
\end{figure}

Se observa entonces que los tests 7, 8 y 9 tuvieron una mejor performance con respecto a los demás.

Algo que se mencionó en el comienzo de la sección principal es que los tests que se realizaron hasta el momento se hicieron desactivando algunas características que vienen seteadas por defecto en $CPLEX$, como los cortes. Este es uno de los motivos por los cuales los tiempos de resolución de los problemas son tan altos, pero por otro lado, hasta el momento no se utilizó ningún tipo de heurística inicial que permita reducir el problema y acotar los valores de la función objetivo.

Como los grafos que se utilizaron de prueba son bastante pequeños, y dado que las heurísticas iniciales de reducción del problema de $CPLEX$ tienen un comportamiento impredecible, se decidió implementar heurísticas que permitan acotar la cantidad de colores de la solución de manera que se puedan utilizar en los experimentos posteriores y que sirvan para simplificar el problema, evitar cálculos innecesarios y por ende mejorar la performance del sistema.

En la siguiente ronda de tests se incluirán algunas heurísticas iniciales para realizar dicha acotación, tanto superiormente como inferiormente.

\subsubsection{Ronda número 3}

En esta ronda de pruebas se agregan tres heurísticas iniciales para ayudar a $CPLEX$ a resolver el problema de forma más rapida, dado que las mismas sirven para acortar el rango de valores de la función objetivo, tanto inferiormente como superiormente. Las mismas se detallan en la sección ``Heurísticas Iniciales''.

Realizando las pruebas nuevamente con los mismos tipos que la ronda número 2, pero ahora usando las heurísticas iniciales de cota inferior y superior, se notó una notable mejora de tiempos. A continuación se muestra el gráfico con los tiempos requeridos para cada uno de los tipos de test, con grafos de 3 a 13 nodos y 70\% de densidad:

\begin{figure}[H]
\centering
\includegraphics[scale=0.5]{../tests/resultados/resultados3/tiempos.png}
\caption{Vista de los tiempos}
\end{figure}

Como se puede observar, los tiempos son mucho mas cortos y menores a un segundo, para todos los grafos de prueba, y para todos los tipos de combinación de parámetros.  Esto deja ver que las heurísticas iniciales son una herramienta muy importante a la hora preparar una solución para el problema, donde se tratan de buscar las que sean lo más baratas en costo de ejecución y lo más eficiente acotando el problema.

Algo más a observar es la prevalencia de los tiempos de los tipos 7, 8 y 9, que se destacan entre los tipos de combinación de parámetros, con los primeros puestos en cuanto a tiempo de ejecución.

\subsubsection{Ronda número 4}

En esta ronda lo que se planeó hacer es fijar los parámetros que se estuvieron usando para los demás rondas de tests, en particular, elegir alguna combinación de ellos (algún tipo de combinación). Anteriormente, se mencionó que los tipos 7, 8 y 9 eran los que se veían como mejores, dado el tiempo de respuesta a la hora de resolver el problema. Para que la cantidad de tests no crezca exponencialmente, tomaremos el tipo 7 como ejemplo para los siguientes experimentos.

Las combinaciones que siguen son en base a nuevos parámetros, con los demás seteados según el tipo 7. Los nuevos parámetros a combinar tienen que ver con las formas de elegir el nodo ($CPX\_PARAM\_NODESEL$), para seguir con el árbol de branching y con las heurísticas locales dentro de cada branching ($CPX\_PARAM\_LBHEUR$). Como se supone que los resultados del primer parámetro puede variar de acuerdo a si hay o no heurísticas locales, parece ser interesante ver que pasa con esta combinación de parámetros.

Los tipos de combinación se detallan a continuación:

\begin{enumerate}
\item Tipo1:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_BESTBOUND\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF\\

\item Tipo2:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_BESTBOUND\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\

\item Tipo3:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_BESTEST *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF *\\

\item Tipo4:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_BESTEST\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON *\\

\item Tipo5:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_DFS *\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_OFF *\\

\item Tipo6:

CPX\_PARAM\_NODESEL $\to$ CPX\_NODESEL\_DFS\\
CPX\_PARAM\_LBHEUR $\to$ CPX\_ON\\

\end{enumerate}

Las pruebas se realizaron con grafos de 25 a 50 nodos, con un 70\% de densidad. En el gráfico de tiempos que sigue se puede observar que los tiempos son bastante buenos. Pero también se puede decir que si bien las estrategias elegidas para correr estas pruebas resultaron ser buenas para estas instancias de prueba, para 25 nodos resultó ser muy mala, ya que los tiempos para resolver el problema eran muy altos, casi al mismo nivel de los tiempos de la ronda 1 para los grafos de 13 nodos. Con esto se puede deducir que las estrategias elegidas pueden resultar muy buenas o muy malas, dependiendo de la instancia en la que la pruebe.

Por el motivo mencionado anteriormente, se decidió no graficar los tiempos para la instancia de 25 nodos, ya que representa un outlier dentro de la ronda y no aporta ningún tipo de información adicional.

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{../tests/resultados/resultados4/tiempos.png}
\caption{Vista de los tiempos}
\end{figure}

Se puede notar que los tiempos de ejecución son muy similares entre los diferentes tipos de parámetros. Esto indica que el hecho de tener o no heurísticas locales en cada branching no varía mucho los resultados para estos tests en particular, aunque si se observa bien, los tipos 1, 3 y 5, que tienen las heurísticas locales desactivadas, en las ultimas tres instancias tardan un poquito más que los tipos con las heurísticas activadas.

Con respecto a la selección del nodo del árbol para realizar el branching, si se toman los tipos 2,4 y 6 que son los que en las pruebas consumen menos tiempos en general, se puede ver que casi no hay diferencia entre una elección u otra, por lo que podemos decir que parece no ser muy importante este parámetro para este problema.

Para esta ronda, además de analizar los tiempos, se analizaron las heurísticas iniciales, que se implementaron para obtener cotas superiores e inferiores al problema antes de correr $CPLEX$ para la instancia de entrada, de forma tal de simplificar el modelo y eliminar filas y columnas de la matriz de restricciones, haciendo que el tiempo disminuya.

A continuación para las instancias de prueba se realizó un gráfico en el que se ve, la solución óptima de cada una de las instancias, y cuales son las cotas superior e inferior que obtuvieron las heurísticas iniciales:

\begin{figure}[H]
\centering
\includegraphics[scale=0.75]{../tests/resultados/resultados4/cotas.png}
\caption{Vista de los tiempos}
\end{figure}

Como se puede observar las cotas funcionaron bastante bien, siendo así que no se encontraron muy distanciadas de la solución óptima. Esto es muy bueno verlo para poder entender por qué los tiempos de respuesta son bajos: es por que en general para las instancias probadas la cantidad de información que $CPLEX$ tenía que manejar era bastante más reducida que la información que puede haber inicialmente sin correr las heurísticas iniciales.

\section{Heurísticas Iniciales}

Para cada problema se ejecutan heurísticas iniciales que nos acota el valor de la función objetivo. Con estas cotas transformamos el problema en otro con menor cantidad de filas y menor cantidad de columnas comparado con el problema sin las mismas.

\subsection{De Cota Superior}

Para encontrar una cota superior al valor de la función objetivo del problema existen dos heurísticas, que se implementaron para tratar de tener un mejor resultado, ya que una puede ser mala para una instancia y la otra no, o viceversa. Por esta razón, para cada instancia, se llama a estas dos implementaciones, y se queda con el menor valor de ambas.

En el problema original hay tantos posibles colores como nodos del grafo. Al acotarlo superiormente logramos eliminar no solo las columnas $w_j$ correspondientes a los colores, sino también las filas de la matriz de tipo:

$$x_{p_j} + x_{q_j} \le w_j$$

de modo que no habrá restricciones de este tipo para $j > U$, siendo $U$ el valor de la cota superior.

Los métodos utilizados para esto son $heuristicBFSUpperBound$ y $heuristicSequentialUpperBound$, que se describen a continuación:

\begin{itemize}

\item $heuristicBFSUpperBound$: Como lo indica su nombre, se recorre el grafo en orden $BFS$ desde algún nodo inicial dado, y se va coloreando los nodos teniendo en cuenta sus adyacentes y los colores ya usados. Se identifica los colores numerándolos y se busca pintarlos siempre con el color más chico. Por ejemplo, dado un nodo si sus adyacentes se encuentran pintados con los colores 2, 3 y 4, y no hay ninguno pintado con el color 1, entonces se procede a pintar dicho nodo con ese color.

\item $heuristicSequentialUpperBound$: Se ordenan los nodos de acuerdo a sus grados, y se van recorriendo de mayor a menor grado. Al igual que la heurística anterior, se identifican los colores numerándolos. Dado un nodo, se lo pinta del menor número disponible, evitando pintarlo del mismo color que alguno de sus vecinos, al igual que la heurística anterior.
\end{itemize}

\subsection{De Cota Inferior}

Para obtener una cota inferior para el problema se implementó la heurística $heuristicCliqueLowerBound$ que busca una clique maximal para el grafo del problema. De este modo podemos decir que la cantidad de colores necesarios para pintar el grafo es almenos la cantidad dada por el tamaño de la clique.

Se intenta buscar la clique más grande posible. Dado que es más probable encontrar cliques más grandes entre nodos de mayor grado, y para maximizar la eficiencia de la heurística se ejecuta la misma varias veces, cada vez desde distinto nodo inicial en orden de mayor a menor grado y se busca una clique maximal que contenga a este nodo. Los tests anteriores ejecutan la heurística hasta $3 (tres)$ veces. Decidimos mantener este valor dado que los resultados de la heurística con esta cantidad de veces son muy buenos y no notamos una mejoría al aumentarlo.

Para encontrar la clique maximal se utilizó el algoritmo $New-Best-In$ del paper ``A Simple Clique Camouflaging Against Greedy Maximum Clique Heuristics'' de Stanislav Busygin que se puede ver en la referencia \cite{newbestin}.

\section{Flujo del sistema para el ejercicio 1}

\begin{figure}[H]
\centering
\includegraphics[scale=0.2]{figuras/flow1.png}
\caption{Flujo del sistema}
\end{figure}

Como se puede ver, el sistema genera un archivo auxiliar de extensión $.lp$ (que es el que se le da de entrada a $CPLEX$) a partir de otro archivo de extensión $.col$ que suele ser más simple de generar. El intérprete de archivos $.col$ arma un grafo auxiliar que se mantiene durante toda la ejecución, que sirve para las heurísticas y para experimentos de los ejercicios posteriores.